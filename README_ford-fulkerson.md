포드-풀커슨(Ford-Fulkerson) 알고리즘
------------------
1956년 포드와 풀커슨에 의해 발견된 알고리즘이다. 최대 흐름 최소 컷 문제를 다루는 알고리즘. 특정 가중치를 갖는 꼭짓점과 꼭짓점 사이에 가장자리를 가진 네트워크가 주어진다면, 네트워크는 얼마나 많은 flow를 처리할 수 있는지 ** 네트워크 유량 문제 **를 해결 할 수 있다. flow는 컴퓨터 네트워크를 통한 데이터를 의미한다. 즉, 특정한 지점에서 다른 지점으로 데이터가 얼마나 흐르고 있는지 측정하는 알고리즘. 데이터 뿐만 아니라 다양한 분야에 활용되고 있다.
 
**⋅ 코드 구현을 위한 기본 용어**
- 용량 : 정점 u에서 v로 전송할 수 있는 최대 용량
- 유량 : 정점 u에서 v로 실제 흐르고 있는 유량
- 잔여 용량 : r(u.v) = c(u,v) - f(u,v)
  - 간선의 용량과 실제로 흐르는 유량의 차이
- 소스 s : 모든 유량이 시작되는 정점
- 싱크 t : 모든 유량이 도착하는 정점
- 증강 경로
  - 소스에서 싱크로 유량을 보낼 수 있는 경로
  - 증강 경로로 보낼 수 있는 최대 유량은 포함된 간선의 잔여 용량 중에서 가장 작은 값

**⋅ 유량 네트워크가 만족해야 하는 세 가지 속성**
- 유량 제한 속성 : f(u,v) ≤ c(u,v)
- 유량의 대칭성 : f(u,v) = - f(v,u)
  - u에서 v로 유량이 흐르면 v에서 u로 음수의 유량이 흐르는 것과 동일
- 유량의 보존 : 각 정점에 들어오는 유량과 나가는 유량은 같음
![ff1](https://user-images.githubusercontent.com/101931446/165816278-1f106e32-4e73-481f-9421-b00a58f2dfd7.jpg){: width="250" height="250"}
위의 그래프를 바탕으로 s에서 t까지의 최대 유량을 계산해보자.
경로는 총 두 개를 구할 수 있다.
![ff2](https://user-images.githubusercontent.com/101931446/165816335-d78a3bb4-7ecd-4dca-92c1-e016c94decaf.jpg)
이 경로에서 흐를 수 있는 최대 유량은 1이다.
![ff3](https://user-images.githubusercontent.com/101931446/165816383-22c82386-1f78-4921-a0d4-dd05a65ffca2.jpg)
다른 경로를 선택했을 때의 최대 유량은 2이다.
최대 유량을 찾는 문제이므로 밑의 사진의 경로가 적절하다.
여기서 도입해야 할 것은 무엇일까?

**⋅ 유량 상쇄의 필요성**
![ff4](https://user-images.githubusercontent.com/101931446/165816432-604fee70-4095-4d30-a770-2df2d62d6b4c.jpg)
- 증강 경로를 어떻게 선택하느냐에 따라 최대 유량을 찾을 수 없는 경우 때문이다.
- 새 유량을 보내는 것과 기존의 유량을 상쇄하는 것은 같은 연산


💻 알고리즘 동작 방식 (Pseudo Code)
```
Ford-Fulkerson (G, s, t)

initialize flow_total = 0
while 경로가 존재하는 동안:
	DFS from s to find a flow path to t
	f = min(C(u,v))
	flow_total = flow_total + f
for 경로에 있는 각각의 edge(u,v)
	capacity of the edge c(u→v)를 f만큼 감소 시킴
	capacity of the dege c(v→u)를 f만큼 증가 시킴
 ```

유량 네트워크의 모든 간선의 유량을 0으로 초기화
소스에서 싱크로 유량을 더 보낼 수 있는 경로(잔여 용량이 남은 간선들 이용)를 찾아 유량 보내기를 반복한다.
증강 경로를 찾는 방법에서 DFS를 사용한다면 Ford-Fulkerson 알고리즘
BFS를 사용한다면 ** Edmonds-Karp 알고리즘 **(성능 분석 파트에서 다룬다.)


💻 출력 화면
<img width="1440" alt="ff-6" src="https://user-images.githubusercontent.com/101931446/165822748-a7375f7d-1deb-493f-aaeb-8ea6736639b9.png">


성능 분석
------------------
ford-fulkerson 알고리즘의 시간 복잡도는 O(v𝑓)이다. 여기서 𝑓는 최대 플로우를 말한다.
![ff5](https://user-images.githubusercontent.com/101931446/165816475-02e5dca4-78cd-4c1c-8a86-d7771b1dae99.jpg)

이런 경우, 2번과 20만번이라는 극단적 차이가 나기 때문에 비효율적이다.
그래서 나온 것이 에드몬드-카프 알고리즘


에드몬드-카프(Edmonds-Karp)알고리즘
------------------
1) BFS(너비우선탐색)을 이용한다.
2) 모든 간선에 대해 유량을 더해주면 된다.
3) 가능한 모든 경우의 수를 탐색하기 위해 기본적으로 현재 흐르고 있는 유량을 모두 0으로 설정
4) 이후 정해진 용량(Capacity) 안에서 가능한 용량의 양을 반복적으로 더해주면 됨
5) 가능한 경로를 다 해본다!
6) 음의 유량 가정을 추가함으로써 추가적으로 가능한 경로를 더 찾아낸다.
7) 출발지에서 시작하는 경로의 유량을 다 더해준다.

** ⋅ 에드몬드-카프의 시간 복잡도 **
BFS로 증가경로를 찾는 에드몬드-카프 알고리즘의 특성상, 한 정점에서 가질수 있는 최대의 거리는, 정점의 개수∣V∣
따라서, 한 간선이 병목간선으로 작용할 수 있는 최대의 횟수는 아무리 많아봐야 ∣V∣/2
에드몬즈-카프 알고리즘으로 증가경로를 찾을 때, 잔여 그래프에서 나올 수 있는 간선의 종류는 원래 그래프에 있었던 정방향 간선과, 그 정방향 간선에 각각 1대1로 대응하는 역방향 간선
따라서 최대로 나올 수 있는 간선의 개수는 2∣E∣
증가경로를 찾기 위해 BFS를 한번 수행하는데에 걸리는 시간은 O(∣E∣)
즉, 에드몬드 카프 알고리즘의 시간 복잡도는 O(VE²) 가 된다.

유량 네트워크의 적용 사례
------------------
- 송유관 네트워크에서 두 도시 사이에 보낼 수 있는 석유의 양
- 도로교통망에서 두 도시 사이를 이동할 수 있는 시간당 차량의 수
- 디지털 네트워크에서 두 노드 사이에 전송 가능한 데이터의 대역폭

마치며⋯ 
------------------
포드-풀커슨 알고리즘을 공부하며 네트워크 유량문제를 풀기 위한 다양한 알고리즘들을 발견했다. 
오늘은 포드-풀커슨과 에드몬드-카프에 대해서만 다뤘지만, 후에 참고하기 위해 다른 알고리즘들을 잘 정리해둔 블로그 주소를 첨부한다.

[push-relabel-algorithm](https://koosaga.com/287 "push-relabel")
[dinic-algorithm](https://jech-jose.tistory.com/90 "dinic")
